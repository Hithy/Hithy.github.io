<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>DDIA Note - ya0db9&#39;s Site</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <link rel="canonical" href="https://home.ya0db9.com/post/ddia/">

  
  

  
  

  
  

  <link rel="stylesheet" type="text/css" href="https://home.ya0db9.com//css/combined-min.css">
  <link rel="stylesheet" type="text/css" href="https://home.ya0db9.com//tipuesearch/tipuesearch.css">

</head>
<body class="">

<div class="site-wrap">
  <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="https://home.ya0db9.com/" class="site-title">ya0db9&#39;s Site</a>
      <nav class="site-nav right">
      <a href="https://home.ya0db9.com//about/">About</a>
<a href="https://home.ya0db9.com//tags/">Tags</a>
<a href="https://home.ya0db9.com//contact/">Contact</a>
</form>

      </nav>
      <div class="clearfix"></div>
    </div>
  </div>
</header>

  <div class="post p2 p-responsive wrap" role="main">
    <div class="measure">
      <div class="post-header mb2">
        <h1 class="py2">DDIA Note</h1>
        <span class="post-meta">Jul 21, 2020 </span><br>
        
      </div>

      <article class="post-content">
      
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
Ch-5 Replication
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<div id="outline-container-headline-2" class="outline-3">
<h3 id="headline-2">
Leaders and Followers(主从模式)
</h3>
<div id="outline-text-headline-2" class="outline-text-3">
<div id="outline-container-headline-3" class="outline-4">
<h4 id="headline-3">
同步复制
</h4>
<div id="outline-text-headline-3" class="outline-text-4">
<ul>
<li>
<p>pros</p>
<ol>
<li>
<p>用户读到的数据永远是最新的</p>
</li>
<li>
<p>主节点挂了之后，从节点还是有最新的数据的</p>
</li>
</ol>
</li>
<li>
<p>cons</p>
<ol>
<li>
<p>慢</p>
</li>
<li>
<p>只要一个从节点有问题，拖累整个系统</p>
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-4" class="outline-4">
<h4 id="headline-4">
异步复制
</h4>
<div id="outline-text-headline-4" class="outline-text-4">
<ul>
<li>
<p>pros</p>
<ol>
<li>
<p>无阻塞，主节点可以继续处理写请求</p>
</li>
<li>
<p>在多数据中心中更适用</p>
</li>
</ol>
</li>
<li>
<p>cons</p>
<ol>
<li>
<p>如果主节点挂了，可能所有数据都丢了</p>
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-5" class="outline-4">
<h4 id="headline-5">
启用一个新的从节点流程
</h4>
<div id="outline-text-headline-5" class="outline-text-4">
<ol>
<li>
<p>拍一个主节点的快照</p>
</li>
<li>
<p>把快照复制到从节点</p>
</li>
<li>
<p>从节点连接到主节点，并请求从快照开始的新的数据</p>
</li>
<li>
<p>处理完所有的数据变更，可认为从节点赶上了(catch up)，接着就可以正常工作</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-6" class="outline-4">
<h4 id="headline-6">
处理节点失效
</h4>
<div id="outline-text-headline-6" class="outline-text-4">
<ul>
<li>
<p>从节点失效：追赶式恢复</p>
<p>
从节点重新上线后，从主节点请求从掉线开始的日志，并进行恢复</p>
</li>
<li>
<p>主节点失效：故障转移</p>
<ol>
<li>
<p>确认主节点确实失效了</p>
<p>
节点失效的原因有很多，比如crash，停电，断网等，需要用超时之类的机制确认主节点确实失效了</p>
</li>
<li>
<p>选举新的主节点</p>
<p>
原主节点确定失效后，需要选举出一个新的主节点，这里就需要解决让所有从节点达成共识的问题(consensus problem)</p>
</li>
<li>
<p>重新配置系统让新的主节点生效</p>
<p>
客户端需要把写请求发送到新的主节点。初次之外，原主节点可能随时恢复，在它恢复的时候，它自己可能认为它还是主节点，这时候系统需要强制让它下台，可能的话，变成从节点</p>
</li>
</ol>
</li>
<li>
<p>主节点失效恢复过程中产生的问题</p>
<ol>
<li>
<p>如果是异步复制，新的主节点可能还没有完全更新到旧的主节点的数据。这时候旧的主节点重新加入集群，如何处理这些已经写入进去的数据？常用解决办法是忽略掉旧主节点上未复制出去的数据，但这违背了对客户端持久化的承诺</p>
</li>
<li>
<p>忽略已写入的数据是极其危险的，特别是别的系统对数据库的数据有依赖。比如github之前的一个事故，原主节点已经把计数器主键分配给了某些用户，当它出问题的时候，一个未完全同步到数据的从节点被选举成新的主节点，它将这些主键分配给了其他的用户。而原有的主键已经在redis里面被引用，这样导致原有主键用户的私有数据泄露给新持有该主键的用户</p>
</li>
<li>
<p>有些情况下，可能同时存在两个节点都认为自己是主节点(俗称脑裂,split brain)，这时候两边都可能在写入数据，导致数据出现问题</p>
</li>
<li>
<p>确认主节点失效的超时到底设置多少比较合适？太短会导致开销过大，太长导致总体恢复时间过长</p>
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-7" class="outline-4">
<h4 id="headline-7">
实现复制日志
</h4>
<div id="outline-text-headline-7" class="outline-text-4">
<ol>
<li>
<p>基于语句的复制</p>
<p>
按照sql的语法来，但是会有一些场景不适用</p>
<ul>
<li>
<p>通过now()或者rand()等获取非确定性变量的函数结果是不一致的</p>
</li>
<li>
<p>有些用了自增或者条件语句，需要串行执行，在并发环境下会有很大限制</p>
</li>
<li>
<p>只要不是绝对确定性的语句，有些有副作用的语句(如触发器、存储过程或者用户自定义函数)在不同的副本上会产生不同的副作用</p>
</li>
</ul>
</li>
<li>
<p>基于预写日志(Write-ahead log, WAL)传输</p>
<p>
对于LSM存储引擎，日志是主要存储方式，会在后台压缩并进行垃圾回收；如果是用覆盖写入磁盘的B树，会预先写入日志，以方便在出错的时候恢复</p>
<p>
这是一种比较底层的方式，兼容性和可移植性都不是很好</p>
</li>
<li>
<p>逻辑(基于行)日志复制</p>
<p>
对存储引擎的增、删、改进行一层抽象，忽略掉实现细节，易解析，对外部系统的支持也更好</p>
</li>
<li>
<p>基于触发器的复制</p>
<p>
很多时候只想复制数据的一部分，或者按照更灵活的需求来做复制，往往会考虑到在感兴趣的数据上加入触发器，然后交给应用层代码来处理</p>
<p>
这种方式开销大，容易出错，但是非常灵活</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-8" class="outline-3">
<h3 id="headline-8">
Problems with Replication Lag
</h3>
<div id="outline-text-headline-8" class="outline-text-3">
<p>
   除了用于容错，增加副本节点也用于扩大规模和降低延迟(cdn)，在需要大规模读节点的场景中，基本上只能使用异步复制，异步复制会带来明显的一致性问题</p>
<p>
   最终一致性(eventual consistency)：从节点会在一段时间落后，但是最终会赶上主节点</p>
<div id="outline-container-headline-9" class="outline-4">
<h4 id="headline-9">
Reading Your Own Writes
</h4>
<div id="outline-text-headline-9" class="outline-text-4">
<p>
    read-after-write consistency: 读自己的写保证用户重新刷新页面的时候，总是能读取到自己刚刚提交的内容</p>
<p>
    一般有如下实现方案：</p>
<ul>
<li>
<p>从主节点读刚刚写入的内容</p>
<p>
如果用户可编辑的内容太多，这种方式会严重影响效率(所有的读都从主节点去了)</p>
</li>
<li>
<p>一段时间内从主节点读刚刚写入的内容</p>
<p>
一段时间内从主节点读可以缓解全部从主节点读带来的负载压力</p>
</li>
<li>
<p>按照时间戳读取</p>
<p>
客户端可以记住写入时候的时间戳(可以是逻辑时间戳、版本号啥的)，如果副本中的版本比时间戳旧，一方面可以去读其他副本，另一方面可以等待直到副本同步到更新的数据</p>
</li>
<li>
<p>主节点路由</p>
<p>
如果节点跨越了几个数据中心，可能需要在读取的时候，路由到包含主节点的数据中心</p>
</li>
</ul>
<p>以上方式可以解决单客户端的问题，但是如果用户是多个设备读写同一账户的数据，就要涉及跨设备(cross-device)一致性问题了</p>
<ul>
<li>
<p>记住时间戳会变得困难，一个客户端写，其他客户端是不知道写入的时间戳的</p>
</li>
<li>
<p>如果副本跨数据中心，多个设备可能连接上了不同的数据中心，如果是这样，需要路由到相同的数据中心</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-10" class="outline-4">
<h4 id="headline-10">
Monotonic Reads
</h4>
<div id="outline-text-headline-10" class="outline-text-4">
<p>
    单调读：确保每次读取数据，都不会比之前读取到的数据旧</p>
</div>
</div>
<div id="outline-container-headline-11" class="outline-4">
<h4 id="headline-11">
Consistent Prefix Reads
</h4>
<div id="outline-text-headline-11" class="outline-text-4">
<p>
    前缀一致读：对于一系列按照某种因果顺序发生的写请求，读取这些内容的时候，一定会按照当时的写入顺序读取</p>
</div>
</div>
<div id="outline-container-headline-12" class="outline-4">
<h4 id="headline-12">
复制滞后解决方案
</h4>
<div id="outline-text-headline-12" class="outline-text-4">
<p>
    通过事务在数据库层面保证一致性，降低应用层的复杂度</p>
<p>
    单节点事务已经很成熟，但是分布式事务会麻烦很多，具体参考第7章和第9章</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-13" class="outline-3">
<h3 id="headline-13">
Multi-Leader Replication
</h3>
<div id="outline-text-headline-13" class="outline-text-3">
<div id="outline-container-headline-14" class="outline-4">
<h4 id="headline-14">
应用场景   
</h4>
<div id="outline-text-headline-14" class="outline-text-4">
<p>在单数据中心用多主节点复制模式没有意义，一般用于如下场景：</p>
<ul>
<li>
<p>多数据中心</p>
<p>
在数据中心应用中，单节点和多节点主要优势如下：</p>
<ul>
<li>
<p>性能</p>
<p>
单主节点配置中，每次写入都必须经过互联网才能写入到主节点所在的数据中心；而多主节点只需要写入到当前数据中心的主节点，上层应用不用关心数据中心之间的网络同步细节</p>
</li>
<li>
<p>容忍数据中心失效</p>
<p>
单主节点中如果主节点所在的数据中心挂掉了，需要把其他数据中心的一个节点提升为主节点；而多主节点配置中，其他数据中心可以正常服务，失效数据中心在恢复后可以追赶上来</p>
</li>
<li>
<p>容忍网络问题</p>
<p>
广域网的可靠性远不如数据中心内网，而写入操作往往是同步操作，对数据中心之间的网络更为敏感；多主节点之间的复制往往是异步，容错性更好一些</p>
</li>
</ul>
<p>但是多主节点会有一个严重的问题：如果同一个数据同时被多个数据中心的主节点写入，会造成冲突，这个冲突必须要得到解决</p>
<p>
除此之外，多主节点复制往往是数据库的一个高级功能，一些数据库的功能(自增键、触发器和完整性约束等)在多主节点环境会产生一些副作用</p>
</li>
<li>
<p>客户端的离线操作</p>
<p>
当一些客户端需要在离线的情况下继续工作，例如在不同设备上的日历程序，每个设备上程序的数据库可以看做一个数据中心，数据中心之间的同步延迟可能达到数小时甚至数天</p>
</li>
<li>
<p>协同编辑</p>
<p>
例如Google Docs这样的，每个浏览器有一个本地的副本，用户修改数据时候，会从本地副本复制到服务器和其他客户端</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-15" class="outline-4">
<h4 id="headline-15">
处理冲突
</h4>
<div id="outline-text-headline-15" class="outline-text-4">
<p>
    当两个主节点同时写入同一个数据的时候，就会发生写入冲突</p>
<ul>
<li>
<p>Synchronous versus asynchronous conflict detection</p>
<p>
单主节点是同步写入的，所以不会有这个问题，而多主节点发现冲突的时候，已经太迟了</p>
<p>
原则上可以让多主节点复制的写入编程同步模式，但是这样就失去了多主节点复制的最大优势，还不如考虑使用单主节点</p>
</li>
<li>
<p>Confict avoidance</p>
<p>
解决冲突最直接的办法是避免冲突，如果把对统一用户的写入都放到同一个主节点，就可以避免多主节点写入冲突</p>
<p>
这里就需要给每个用户分配一个合适的主节点，用户的所有写入，都交给其主节点来做</p>
<p>
不过这里也会有个问题，如果被分配的主节点失效或者用户的物理位置移动，可能就需要给用户重新分配一个主节点，这种情况下，还是会面临写入冲突的问题</p>
</li>
<li>
<p>Converging toward a consistent state</p>
<p>
通过算法或者规则让冲突收敛到一致，一般的方式有：</p>
<ul>
<li>
<p>每次写入带上一个唯一的ID，ID最大的写入成功，其他的丢弃；或者带上时间戳，最后写入的成功(last write wins, LWW)。这种方式存在丢失数据的风险</p>
</li>
<li>
<p>给每一个副本分配一个唯一的ID，来自ID最大的副本的数据，覆盖掉其他的数据，这种方式也可能丢失数据</p>
</li>
<li>
<p>把冲突的数据按照规则拼接到一起(比如按照字母顺序，写入&#34;B&#34;和写入&#34;C&#34;冲突，可以考虑合并为&#34;B/C&#34;)</p>
</li>
<li>
<p>记录冲突信息，让应用层处理冲突(例如通知用户)</p>
</li>
</ul>
</li>
<li>
<p>Custom conflict resolution logic</p>
<p>
处理冲突最好的方式还是依赖用户层，一般有两个时机</p>
<ul>
<li>
<p>在写入的时候处理</p>
<p>
只要数据库写入的时候检测到冲突，就通知应用层处理</p>
</li>
<li>
<p>在读取的时候处理</p>
<p>
在写入时候产生冲突，冲突信息被保存下来，用户下次读取的时候，会通知应用层处理</p>
</li>
</ul>
<p>这里的冲突处理粒度是数据库独立的一行或者一个文档，不是以事务的粒度。所以当一个事务原子地执行几次不同的写入，每次写入都会分别考虑这里的冲突解决</p>
</li>
<li>
<p>什么是冲突</p>
<p>
除了这里提到的冲突，第七章和第十二章会讲更多，比如写倾斜问题</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-16" class="outline-4">
<h4 id="headline-16">
Multi-Leader Replication Topologies
</h4>
<div id="outline-text-headline-16" class="outline-text-4">
<p>
    一般分为环装、星状(树形)和完全图</p>
<p>
    前两者容易出现单点问题，后者容易出现特定写入顺序不一致的问题(不同的主节点先后写入同一个内容，其他节点收到的写入顺序可能不一致)</p>
<p>
    通常可以用一个叫做版本向量(version vectors)的技术来解决这个问题，后面再讲</p>
<p>
    总的来说多主节点复制的冲突检测技术并不是一个简单的事情，在使用的时候一定要考虑清楚</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-17" class="outline-3">
<h3 id="headline-17">
Leaderless Replication
</h3>
<div id="outline-text-headline-17" class="outline-text-3">
<p>
   无主节点模式需要客户端把写入数据发给其他的副本，写入顺序不做保证</p>
<div id="outline-container-headline-18" class="outline-4">
<h4 id="headline-18">
Writing to the Database When a Node Is Down   
</h4>
<div id="outline-text-headline-18" class="outline-text-4">
<p>
   一般来说，客户端会并行向多个副本发送读请求，根据版本号，可以知道某些节点因为挂掉之类的问题，存储的内容并不是最新的</p>
<p>
   一般通过两种方式来让数据过期的节点重新获取到最新的数据</p>
<ul>
<li>
<p>Read repair</p>
<p>
客户端一次性会读取多份副本的数据，当发现某些副本落后的时候，由客户端写回过期的副本</p>
</li>
<li>
<p>Anti-entropy process</p>
<p>
启动一些后台进程，持续监视各个副本之间的异同，并把某些副本确实的数据，从其他副本拷贝过去</p>
<p>
这个过程不保证顺序，并且可能会有很大延迟</p>
</li>
<li>
<p>Quorums for reading and writing</p>
<p>
指定三个变量：n(副本数量)、w(至少成功写入w个节点才算成功写入)、r(每次读取副本的数量)</p>
<p>
正常情况下，读写请求会发送给全部n个副本，只有w/r个节点返回成功之后，才认为本次请求成功</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-19" class="outline-4">
<h4 id="headline-19">
Limitations of Quorum Consistency
</h4>
<div id="outline-text-headline-19" class="outline-text-4">
<p>
    选择一个w和r，只要w+r&gt;n，就可以保证写入和读取一定重叠，这样就能保证读取到的数据中，至少一个是最新的</p>
<p>
    如果选择的w和r更小，可能会遇到读取不到最新值的情况，但是能降低延迟和提高可用性</p>
<p>
    但是即便w+r&gt;n，也有可能出现读取不到最新值的情况</p>
<ol>
<li>
<p>使用sloppy quorum的情况</p>
</li>
<li>
<p>如果两个写入同时发生，无法明确发生顺序，这时候唯一安全的方式是合并写入</p>
</li>
<li>
<p>如果写入的时候发生了读取，无法保证读取到的是新值还是旧值</p>
</li>
<li>
<p>如果因为某些原因，整体上少于w个节点写入成功，这时候无法回滚已经成功写入的节点</p>
</li>
<li>
<p>如果一个已经被写入新值的节点挂掉了，在恢复的时候，得到了旧值</p>
</li>
<li>
<p>即便一切工作正常，第九章还会有Linearizability and quorums问题</p>
</li>
</ol>
<p>所以quorum并不是一个绝对准确的，而是一个灵活可调整最新值的概率</p>
<ul>
<li>
<p>Monitoring staleness</p>
<p>
对于主从复制结构的数据库，主节点到从节点的写入顺序一般是一致的，每个节点都维护了当前所在复制日志的位置，通过对比主节点和从节点的日志位置偏移，可以确定落后程度</p>
<p>
而无主节点结构就没有固定的顺序了，这会让监控更加困难。而对于那些只支持read repair(没有 anti-entropy)的数据库，一个节点落后多少是没有限度的</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-20" class="outline-4">
<h4 id="headline-20">
Sloppy Quorums and Hinted Handoff
</h4>
<div id="outline-text-headline-20" class="outline-text-4">
<p>
    如果因为网络问题之类的原因，不能满足数据仲裁的最低要求这时候就出现了选择：</p>
<ul>
<li>
<p>如果成功的节点小于w/r，返回错误比较好？</p>
</li>
<li>
<p>还是说我们允许写入小于w的请求成功，并把把剩下的部分暂存到n个节点之外的其他节点？</p>
</li>
</ul>
<p>后者就是sloppy quorum</p>
<p>
    一旦网络恢复，这些暂存节点会把原有的数据写回去，这就叫做hinted handoff。这个过程提高了写可用性</p>
<ul>
<li>
<p>Multi-datacenter operation</p>
<p>
无主节点结构可以直接用于多数据中心的环境
配置的时候，写请求会发送到所有数据中心的副本上，但是只会等待本数据中心的回复，这样就不会受到延迟和跨数据中心网络问题的影响</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-21" class="outline-4">
<h4 id="headline-21">
Detecting Concurrent Writes
</h4>
<div id="outline-text-headline-21" class="outline-text-4">
<ul>
<li>
<p>LWW</p>
<p>
我们在说写入时并发的时候，其实是指写入的顺序是未定义的，这时候就需要强制对其排序(例如按照时间戳)</p>
<p>
LWW是牺牲了数据的持久性的，有些写入请求虽然返回成功，但是依旧会被覆盖掉</p>
<p>
LWW唯一安全的用法是，所有的key只允许写入一次</p>
</li>
<li>
<p>The “happens-before” relationship and concurrency</p>
<p>
定义并发：如果两个操作之间并不知道对方的存在，就认为是并发</p>
<p>
如果一个操作确切知道自己发生在另一个操作之后，当前操作就可以安全地覆盖掉之前的操作，否则需要处理并发冲突</p>
</li>
<li>
<p>Capturing the happens-before relationship</p>
<p>
每个客户端有一个写入链</p>
<p>
在写入之前，会从服务端获取最新的数据和版本号，在写入的时候，保证上次获得的版本号之前的冲突数据都是处理了的</p>
<p>
写入成功之后，服务端会把最新的版本号，和上次读取到这次写入成功中间的冲突数据一并发回客户端，客户端需要处理掉这些冲突</p>
</li>
<li>
<p>Merging concurrently written values</p>
<p>
根据需求来，增加的话，可以直接在list后面append；删除的话，需要设置墓碑标志，其他的客户端根据设置墓碑的版本号，选择删除还是保留</p>
</li>
<li>
<p>Version vectors</p>
<p>
以上讨论的是单副本中的数据，在无主节点结构中，各个副本也可以设置版本矢量，当读取数据的时候，数据库副本会返回版本矢量给客户端</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-22" class="outline-2">
<h2 id="headline-22">
Ch-7 Transactions
</h2>
<div id="outline-text-headline-22" class="outline-text-2">
<div id="outline-container-headline-23" class="outline-3">
<h3 id="headline-23">
Weak Isolation Levels(弱隔离级别)
</h3>
<div id="outline-text-headline-23" class="outline-text-3">
<div id="outline-container-headline-24" class="outline-4">
<h4 id="headline-24">
Read Committed
</h4>
<div id="outline-text-headline-24" class="outline-text-4">
<ul>
<li>
<p>原理</p>
<p>
读-提交是最基础的事务隔离级别，只保证两件事情：</p>
<ol>
<li>
<p>从数据库中读取到的数据，一定是已经提交过的（没有脏读）</p>
</li>
<li>
<p>向数据库中写入数据，只会覆盖掉已经提交过的（没有脏写）</p>
</li>
</ol>
<p>但是无法解决计数器增量竞争的问题</p>
</li>
<li>
<p>实现</p>
<p>
通过加锁来防止脏写，通过维护新旧两个版本来防止脏读</p>
</li>
<li>
<p>存在的问题</p>
<ol>
<li>
<p>无法解决读倾斜(read skew)问题</p>
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-25" class="outline-4">
<h4 id="headline-25">
SnapShot Isolation and Repeatable Read 
</h4>
<div id="outline-text-headline-25" class="outline-text-4">
<p>
    使用来版本控制，相对读-提交来说的区别在于：读-提交的快照是以查询位粒度的，而快照级别隔离是以事务为粒度的</p>
<p>
    每条记录快照会带上版本号(事务id)，在读取数据库的时候，几种情况会被忽略：</p>
<ol>
<li>
<p>任何晚于当前事务id的版本</p>
</li>
<li>
<p>任何已经终止的事务对应的版本</p>
</li>
<li>
<p>未完成的事务对应的版本</p>
</li>
</ol>
<ul>
<li>
<p>索引问题</p>
<p>
PostgreSQL等引擎把一个对象的多个版本放到同一个内存页来避免更新索引，而CouchDB等数据库用B树作为主体结构，每一次写入快照，都会创建一个新的root节点</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-26" class="outline-4">
<h4 id="headline-26">
Preventing Lost Updates
</h4>
<div id="outline-text-headline-26" class="outline-text-4">
<p>
    读-提交和快照级隔离都主要是为了解决只读事务在遇到并发写的时候，可以看到什么的问题。之前讨论的脏写，只是写事务冲突的一种特殊情况</p>
<p>
    更新丢失通常发生的场景是read-modify-write过程，解决这个问题通常有几种方式</p>
<ul>
<li>
<p>原子写操作</p>
<p>
如果数据库支持原子写(通常是对对象加独占锁或者原子操作强制单线程来实现)，可以把这个过程交给数据库解决。
但是很多时候，我们会在应用层写出read-modify-write的代码，导致无法使用到数据库的原子操作</p>
</li>
<li>
<p>显式加锁</p>
<p>
应用层主动加锁，但是很容易漏掉</p>
</li>
<li>
<p>自动检测更新丢失</p>
<p>
通过快照级别隔离，很多数据库支持自动检测事务更新丢失</p>
</li>
<li>
<p>原子比较和设置</p>
<p>
在写入的时候带入旧内容，只有旧内容匹配的时候，才进行写入：</p>
<div class="src src-sql">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">  <span style="color:#66d9ef">update</span> wiki_pages <span style="color:#66d9ef">set</span> content <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;new content&#39;</span>
         <span style="color:#66d9ef">where</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1234</span> <span style="color:#66d9ef">and</span> content <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;old content&#39;</span></code></pre></div>
</div>
<p>
需要注意的是，如果数据库允许where语句从一个旧的快照上读取内容，还是会导致条件为true</p>
</li>
<li>
<p>冲突解决与复制</p>
<p>
在多副本数据库中，前面说的原子比较操作和加锁都会失效。一般是保留多个冲突版本，并在应用层去处理冲突。
如果操作可交换(在不同副本上以不同的顺序应用这个操作，能够得到相同的结果)，例如计数器递增、向集合中加入元素，是可以合并更新的</p>
<p>
而更为常见的LWW(last write wins)方式却是很容易丢失更新的</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-27" class="outline-4">
<h4 id="headline-27">
Write Skew and Phantoms
</h4>
<div id="outline-text-headline-27" class="outline-text-4">
<p>
    写数据的时候，依赖于之前读取的结果，在读和写之间的过程中，读取的结果变了，写入的时候没有发现，会违背规则。这时候如果写入的是同一个对象，则发生 <em>脏写/更新丢失</em> ；如果是不同对象，则是 <em>写倾斜</em></p>
<p>
    幻读：一个事务的写入，改变了另外一个事务查询的结果</p>
<ul>
<li>
<p>通过实体化冲突来解决问题</p>
<p>
例如订书的例子，可以新建一个表，每一行表示一个预定，包含了时间段和房间号。在事务预定的时候，加锁对应的行，即可避免冲突</p>
<p>
但是问题在于，如何实体化冲突，是一个比较困难并且容易出错的问题，而且把并发控制机制泄漏到数据模型中也不够优雅。所以在有备选方案的情况下，不要用这个方案</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-28" class="outline-3">
<h3 id="headline-28">
Serializability(串行化)
</h3>
<div id="outline-text-headline-28" class="outline-text-3">
<p>
   在使用之前的隔离级别通常会有以下挑战：</p>
<ol>
<li>
<p>隔离级别难以理解，而且不同数据库实现不一样</p>
</li>
<li>
<p>很难去确定应用层代码在某种隔离级别上运行是否安全，特别是规模较大的应用</p>
</li>
<li>
<p>没有好的工具去检测竞态，而且问题往往发生在特定的时间</p>
</li>
</ol>
<p>所以通常的解决方法是：串行化隔离</p>
<p>
   常用三种技术：</p>
<ol>
<li>
<p>严格按照串行顺序执行</p>
</li>
<li>
<p>两阶段锁(2PL, Two-phase locking)</p>
</li>
<li>
<p>乐观并发控制技术，例如可串行化的快照隔离(SSI, serializable snapshot isolation)</p>
</li>
</ol>
<div id="outline-container-headline-29" class="outline-4">
<h4 id="headline-29">
Actual Serial Execution
</h4>
<div id="outline-text-headline-29" class="outline-text-4">
<p>
    考虑到内存越来越便宜，OLTP事务通常很短而且读写很少，所以可以考虑：完全移除掉并发，同一时间，只能以串行的方式，执行一个事务</p>
<ul>
<li>
<p>Encapsulating transactions in stored procedures</p>
<p>
一次性把事务代码直接提交给数据库的操作，叫做存储过程(stored procedure)。如果所有数据都在内存中，完全避免网络和磁盘I/O的开销，这种串行事务的效率也会很高</p>
<p>
存在的问题在于：</p>
<ol>
<li>
<p>语言不通用</p>
</li>
<li>
<p>代码难以维护和调试</p>
</li>
<li>
<p>这一层的代码常常是共享代码，其性能非常敏感</p>
</li>
</ol>
</li>
</ul>
<ul>
<li>
<p>分区</p>
<p>
通常把数据库独立到各个分区，每个分区跑一个实例，可以利用到多核的优势</p>
<p>
但如果存在跨分区或者二级索引，会增加大量的协调代码，极大影响性能</p>
</li>
<li>
<p>可实现串行化隔离的约束条件</p>
<ol>
<li>
<p>事务必须简短高效</p>
</li>
<li>
<p>绝大部分数据需要内存处理，磁盘I/O尽量少</p>
</li>
<li>
<p>写入吞吐量必须很低才能在单核使用，否则需要分区</p>
</li>
<li>
<p>跨分区事务尽量少</p>
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-30" class="outline-4">
<h4 id="headline-30">
Two-Phase Locking(2PL)
</h4>
<div id="outline-text-headline-30" class="outline-text-4">
<p>
    近三十年来唯一广泛使用的串行化算法</p>
<p>
    快照隔离允许读的时候写，或者写的时候读，但是两阶段锁不允许这个操作，这是它们最大的区别</p>
<ul>
<li>
<p>实现</p>
<ol>
<li>
<p>读取一个对象，需要获取共享锁</p>
</li>
<li>
<p>写入一个对象，需要获取独占锁</p>
</li>
</ol>
<p>共享锁之间不冲突，独占锁和任意锁都冲突</p>
</li>
</ul>
<p>这样就容易发生死锁，比如两个事务都要对一个对象有一个读取阶段和写入阶段，如果两个事务同时到达写入阶段，就会相互等待对方放弃读锁</p>
<p>
    数据库一般都可以通过中止其中一个事务来断掉死锁，并交给应用层处理</p>
<ul>
<li>
<p>开销</p>
<ol>
<li>
<p>锁的获取和释放</p>
</li>
<li>
<p>中断了并发</p>
</li>
<li>
<p>死锁导致的重试</p>
</li>
</ol>
</li>
<li>
<p>Predicate locks(谓词锁)</p>
<p>
到目前为止，2PL能够解决除了幻读以外的所有问题，但是幻读问题依旧，所以这里引入谓词锁</p>
<p>
谓词锁对应一个查询条件，只要满足这个条件的对象，都属于谓词锁的保护</p>
<p>
实现：</p>
<ol>
<li>
<p>A事务要获取满足查询条件的对象，必须以共享锁模式获取这个查询条件的谓词锁，如果存在事务拿到了满足谓词的任意对象的独占锁，A事务必须等待独占锁释放</p>
</li>
<li>
<p>A事务要修改任何对象，首先要检查这个对象的旧值和新值是否满足任意存在的谓词锁，如果有事务持有这个谓词锁，A必须等到其他事务提交或者放弃</p>
</li>
</ol>
<p>谓词锁可以保护数据库中还不存在但马上会被写入的数据(幻读)</p>
</li>
<li>
<p>谓词锁优化——索引区间锁(Index-range locks)</p>
<p>
谓词锁往往性能不够好，所以一般会把谓词扩大到索引。比如查询一个房间在某个时间段是否预定，房间号和时间区间都可能存在索引，这样就可以把谓词限定在：某个房间的全部时间；某个时间段的全部房间。</p>
<p>
如果没有合适的索引，甚至可以锁整张表</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-31" class="outline-4">
<h4 id="headline-31">
Serializable Snapshot Isolation(SSI)
</h4>
<div id="outline-text-headline-31" class="outline-text-4">
<p>
    相对于2PL，SSI是一种乐观的控制方式，SSI使用一些算法来检测写入冲突并决定中止哪些事务，一般是基于过期的条件做决定，分两种情况：</p>
<ol>
<li>
<p>检测是否读取了一个过期的MVCC对象版本</p>
<p>
如果一个事务已经写入了，但是未提交，这时候读取这个值，是可以知道发生冲突了的，但是可以不阻止。</p>
<p>
一方面是因为后面的事务读取之后，可能并不写入，也就是不会有写倾斜问题；另一方面，如果第一个事务异常中止了，后面的事务可以安全提交</p>
</li>
</ol>
<ol>
<li>
<p>检测写入是否影响到之前的读取</p>
<p>
多个事务同时读了一个值的时候，其中一个事务要进行写入，也是可以知道冲突的(例如前面提到的谓词锁)，这里也不阻止写入</p>
<p>
一方面是因为前面读了这个值的事务，不一定会写入，也可能异常终止；另一方面，写入的时候也能发现被改了，这时候终止也来得及</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-32" class="outline-2">
<h2 id="headline-32">
Ch-9 Consistency and Consensus
</h2>
<div id="outline-text-headline-32" class="outline-text-2">
<div id="outline-container-headline-33" class="outline-3">
<h3 id="headline-33">
Consistency Guarantees
</h3>
<div id="outline-text-headline-33" class="outline-text-3">
<p>
   最终一致性的保证不够强，很多bug只有在边界条件或者高强度并发的时候才能发现，所以需要一个更强的保证，以降低应用层的复杂度</p>
<p>
   事务和分布式一致性的区别：</p>
<ul>
<li>
<p>事务主要用于避免由与并发执行事务产生的竟态</p>
</li>
<li>
<p>分布式一致性主要用于协调副本在面临延迟和faults时候的状态</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-34" class="outline-3">
<h3 id="headline-34">
Linearizability(可线性化)
</h3>
<div id="outline-text-headline-34" class="outline-text-3">
<p>
   基本思想是：让系统看上去只有一份数据，并且所有操作都是原子的</p>
<p>
   对于不重叠的读写操作，按原子顺序来就好了；如果读写操作重叠，需要保证：所有的操作在时序上必须向前，不能回退</p>
<p>
   也就是说，一旦一个新的值被写入/读取，后面所有的连续读操作都看到新值，直到它再次被写入</p>
<div id="outline-container-headline-35" class="outline-4">
<h4 id="headline-35">
Relying on Linearizability
</h4>
<div id="outline-text-headline-35" class="outline-text-4">
<p>
    一些依赖于可线性化的用例</p>
<ul>
<li>
<p>加锁和Leader节点的选举</p>
<p>
一旦新的主节点被选出来，后续节点读取到的主节点，一定要是新的主节点</p>
</li>
<li>
<p>约束和唯一性保证</p>
<p>
用户名、邮件名等唯一性保证，有点像加锁；又比如银行交易账单、订票系统</p>
</li>
<li>
<p>跨通道时序依赖</p>
<p>
比如两个人用不同设备看比赛结果，他们之间相互交流的结果，需要和各自从设备上看到的结果一致</p>
<p>
又比如，系统A往数据库写了东西，然后以其他信道(例如消息队列)通知系统B去处理，系统B在处理的时候，需要保证从数据库能读取到A刚刚写入的内容</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-36" class="outline-4">
<h4 id="headline-36">
实现线性化系统
</h4>
<div id="outline-text-headline-36" class="outline-text-4">
<ul>
<li>
<p>单主节点系统：部分支持</p>
<p>
如果都是从主节点读取或者同步写入到各个副本，原生就是可线性化的</p>
<p>
也有些情况不是，比如bugs，或者说设计上就是不可线性化的(使用快照隔离)</p>
</li>
<li>
<p>选举算法：支持</p>
<p>
例如ZooKeeper或者etcd，都有实现线性化选举算法</p>
</li>
<li>
<p>多主节点：不支持</p>
<p>
设计上就不是可线性化的</p>
</li>
<li>
<p>无主节点：可能不支持</p>
<p>
只有合理配置，在一定需求范围内的quorum可能支持</p>
<p>
像什么基于时间戳的lww算法完全不可以</p>
</li>
</ul>
<p>对于只有读写操作的quorum，可以支持线性化：</p>
<ol>
<li>
<p>在读操作返回之前，同步执行read repair</p>
</li>
<li>
<p>在写操作发送写入数据之前，必须读取最新的节点quorum状态</p>
</li>
</ol>
<p>但是这种方式无法支持compare-and-set操作，所以最安全的方式，还是假定无主节点不支持线性化</p>
</div>
</div>
</div>
</div>
</div>
</div>

      </article>

      

      

    </div>
  </div>
</div>
    <footer class="footer">
      <div class="p2 wrap">
        <div class="measure mt1 center">
      <nav class="social-icons icons">
<a class="fa fa-rss rss" href="/index.xml"></a>

</nav>

          <small>
            Copyright &#169; 2017<br>
            Powered by <a href="http://gohugo.io/" target="_blank">Hugo</a> &amp; <a href="https://github.com/azmelanar/hugo-theme-pixyll" target="_blank">Pixyll</a>
          </small>
        </div>
      </div>
    </footer>

    
    <script src="/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    
    
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-156425913-1', 'auto');
  ga('send', 'pageview');

</script>



</body>
</html>

