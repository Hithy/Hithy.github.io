<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ya0db9&#39;s Site</title>
    <link>http://home.ya0db9.com/post/</link>
    <description>Recent content in Posts on ya0db9&#39;s Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 03 Feb 2020 16:10:46 +0800</lastBuildDate>
    
	<atom:link href="http://home.ya0db9.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Effective C&#43;&#43;笔记</title>
      <link>http://home.ya0db9.com/post/effective-cxx/</link>
      <pubDate>Mon, 03 Feb 2020 16:10:46 +0800</pubDate>
      
      <guid>http://home.ya0db9.com/post/effective-cxx/</guid>
      <description>effecitve c++ 笔记  Ch-1  Item 1: view C++ as a federation of languages   c++继承了c的部分，增加了面向对象的设计，增加了模板，以及标准模板库  这四个部分可以看做四种子语言，相对独立 Item 2: Prefer consts, enums, and inlines to #defines     使用const变量替换掉#define，后者只是做简单替换，对编译器透明，可能会导致生成重复对象代码(obj文件?)    相对于双重const的指针的char*字符串，更推荐使用const限定的string对象    类成员常量(部分如int, char, bool等内置类型)如果不被取址，可以只声明，不定义 class GamePlayer { private: static const int NumTurns = 5; // constant declaration  int scores[NumTurns]; // use of constant  };    如果需要取址，需要在实现文件中定义: const int GamePlayer::NumTruns;    除此之外，可以使用枚举变量替换常量，以兼容一些老的编译器，以支持用作数组声明: class GamePlayer { private: enum { NumTurns = 5 }; // &amp;#34;the enum hack&amp;#34; — makes  // NumTurns a symbolic name for 5  int scores[NumTurns]; // fine  };      使用内联模板函数替代#define实现的宏函数，以降低复杂度   Item 3: Use const whenever possible     指针*之前的cosnt限定指向的数据，*之后的const限定指针变量本身    迭代器的const等价于T* const，而const_iterator等价于const* T const std::vector&amp;lt;int&amp;gt;::iterator iter = vec.</description>
    </item>
    
    <item>
      <title>Hugo &amp; org mode</title>
      <link>http://home.ya0db9.com/post/first-hugo-post/</link>
      <pubDate>Thu, 09 Jan 2020 20:16:41 +0800</pubDate>
      
      <guid>http://home.ya0db9.com/post/first-hugo-post/</guid>
      <description> Happy hacking, Emacs ♥ you! </description>
    </item>
    
    <item>
      <title>透明代理(nuc后续)</title>
      <link>http://home.ya0db9.com/post/2019-10-19-%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/</link>
      <pubDate>Sat, 19 Oct 2019 21:17:32 +0800</pubDate>
      
      <guid>http://home.ya0db9.com/post/2019-10-19-%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/</guid>
      <description>0x00 前言   nuc用了一段时间了，路由功能还是很稳定，用之前的方案做透明代理还是挺折腾的，一直搁置了。  不过最近找到了一个裸延迟20ms的vps，于是打算开始折腾透明代理。  网络：openvpn+kcptun  路由：iptables+iproute2+xtables(geoip)  DNS: dnsmasq 0x01 基础网络   vps的延迟本身还是很低的，但是由于某些原因，tcp的连接还是很不稳定，所以加了一层kcptun( apt install kcptun 安装) 服务端运行： kcptun-server -t &amp;#34;127.0.0.1:1194&amp;#34; -l &amp;#34;:1234&amp;#34; -mode fast3 -nocomp -sockbuf 16777217 -dscp 46   将udp的1234端口映射到1194(openvpn)  客户端(本地路由器)运行： kcptun-client -r &amp;#34;{vps ip}:1234&amp;#34; -l &amp;#34;127.0.0.1:1024&amp;#34; -mode fast3 -nocomp -autoexpire 900 -sockbuf 16777217 -dscp 46   这样就将本地的1024端口映射到vps的1194端口了  然后就是openvpn的配置，相关细节比较复杂，这里就不展开了，只是说结果。在openvpn连接好之后，在两端都会有一个tap设备(虚拟网卡)，设备的地址在同一个网段之内，可以直接Ping通，这时候可以把vps看做一个直接连到本地路由器(nuc)的网关了。如果我们把本地的默认路由设置为vps(tap端的地址)，并在在vps做了nat，就可以实现全部流量走vps了。 0x02 路由   这里我们需要根据数据包的目的地进行路由，国内的走我们正常的网关(光猫)，国外的走vps。可以用netfilter的一个扩展 Xtables-addons 来实现，装好xtables之后，iptable就多了一项geoip的模块，以识别ip地址位置。然后需要下载geoip数据并构建，以便geoip模块查询，这里不展开了。iptables命令： iptables -t mangle -A OUTPUT -m geoip !</description>
    </item>
    
    <item>
      <title>折腾NUC</title>
      <link>http://home.ya0db9.com/post/2019-03-25-%E6%8A%98%E8%85%BEnuc/</link>
      <pubDate>Mon, 25 Mar 2019 00:25:17 +0800</pubDate>
      
      <guid>http://home.ya0db9.com/post/2019-03-25-%E6%8A%98%E8%85%BEnuc/</guid>
      <description>0x00 前言   从过年回来到现在，一直在寻找路由器的替代品，一台设备集成路由、防火墙和基础的私有云。因为现在还不稳定的原因，不能组一台高性能网关（没地方放），而且这种设备基本上是通宵开机，不能影响休息，所以噪音不能太大，所以带机械硬盘和大风扇的就不用考虑了。  现在用是本科留下来的极路由2，因为固件不多，只能将就官方的系统，不过换成openwrt源之后，也实现了一些扩展，包括ss和v2ray的非透明代理（通过端口访问）。作为路由器来说，功能已经满足需求了，但是受限与性能和百兆网口，无法实现更加高级的功能。  后来在坛子里面收了台NUC，正好赶上鱼竿厂SSD降价，搭了一个简单的私有云（nextcloud方案），勉强满足了现有的需求。但是NUC最大的遗憾是只有一个独立的网口（不要提那个什么骷髅，穷！）。  前段时间也在淘宝买了台ER-X，折腾了两天，算是解决了百兆网络的瓶颈。因为性能还是捉急，也没有物理的扩展性（非标准POE真的坑），做不了独立的网关。不过基于Debian的EdgeOS真的好用，而且最新版系统中用了systemd管理服务，在软件方面有很大的潜力，于是打算稳定用了。但天有不测风云，用了两天，路由器莫名挂了，reset都没用，变砖了？！只好联系卖家寄了回去。后来想想，这东西相对极路由来说，其实并没有本质的提升，作为网关还需要额外的设备（wifi，透明代理受限于内核不能用）。售后也墨迹，两周没给出实质性的回复，索性退货了。  后来又去看了下各种软路由、硬路由的评测，顺便总结了下需求：    不占地方，ITX以上的就不考虑了    噪音小    性能不能太差    有一定硬件扩展能力    回过头来看，才发现NUC真的不错：小巧、core i系列处理器、pcie m.2、7mm sata、自带无线网卡……近乎完美，然而，它只有一个网口。虽然也能配置成单臂路由，但是也需要额外的设备（交换机支持VLAN）。最后，只能折中一下，在usb口上插一张胡会长同款有线网卡。 方案   最初本想在BSD上面搭建，但是折腾一段时间后弃疗了，Linux真香！    基础系统：ubuntu 18.04 x64 desktop    网络设备管理：systemd-networkd    防火墙：iptables    DNS+DHCP：dnsmasq    AP：hostapd    动态域名：ddclient    web：apache2    私有云：nextcloud    媒体中心：emby    远程下载：transmission-daemon    代理：v2ray+shadowsocks-libev    透明代理：iptables tproxy（待续）   0x01 基础系统   这里选择ubuntu桌面版的唯一原因是：省事。  系统安装没什么说的，pcie硬盘装系统，sata装数据。 网络配置   三张网卡：eth0、eth1和wlan0。第一个是板载网卡，第二个是usb网卡，第三个是无线。  使用systemd-networkd配置网络。eth0作为wan口，只需要配置一个能上网的IP就行，这里配置为192.</description>
    </item>
    
  </channel>
</rss>