<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Effective C&#43;&#43;笔记 - ya0db9&#39;s site</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="ya0db9" /><meta name="description" content="effecitve c&#43;&#43; 笔记 Ch-1 Item 1: view C&#43;&#43; as a federation of languages c&#43;&#43;继承了c的部分，增加了面向对象的设计，增加了模板，以及标准模板库 这四个部分可以看做四种子语言，相对独立 Item 2:" /><meta name="keywords" content="ya0db9, blog, org" />






<meta name="generator" content="Hugo 0.83.1 with theme even" />


<link rel="canonical" href="https://home.ya0db9.com/post/effective-cxx/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Effective C&#43;&#43;笔记" />
<meta property="og:description" content="effecitve c&#43;&#43; 笔记 Ch-1 Item 1: view C&#43;&#43; as a federation of languages c&#43;&#43;继承了c的部分，增加了面向对象的设计，增加了模板，以及标准模板库 这四个部分可以看做四种子语言，相对独立 Item 2:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://home.ya0db9.com/post/effective-cxx/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-02-03T16:10:46&#43;08:00" />
<meta property="article:modified_time" content="2020-02-03T16:10:46&#43;08:00" />

<meta itemprop="name" content="Effective C&#43;&#43;笔记">
<meta itemprop="description" content="effecitve c&#43;&#43; 笔记 Ch-1 Item 1: view C&#43;&#43; as a federation of languages c&#43;&#43;继承了c的部分，增加了面向对象的设计，增加了模板，以及标准模板库 这四个部分可以看做四种子语言，相对独立 Item 2:"><meta itemprop="datePublished" content="2020-02-03T16:10:46&#43;08:00" />
<meta itemprop="dateModified" content="2020-02-03T16:10:46&#43;08:00" />
<meta itemprop="wordCount" content="8132">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Effective C&#43;&#43;笔记"/>
<meta name="twitter:description" content="effecitve c&#43;&#43; 笔记 Ch-1 Item 1: view C&#43;&#43; as a federation of languages c&#43;&#43;继承了c的部分，增加了面向对象的设计，增加了模板，以及标准模板库 这四个部分可以看做四种子语言，相对独立 Item 2:"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">ya0db9</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">ya0db9</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Effective C&#43;&#43;笔记</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-02-03 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#headline-1">Ch-1</a>
<ul>
<li><a href="#headline-2">Item 1: view C++ as a federation of languages</a>
</li>
<li><a href="#headline-3">Item 2: Prefer consts, enums, and inlines to #defines</a>
</li>
<li><a href="#headline-4">Item 3: Use const whenever possible</a>
<ul>
<li><a href="#headline-5">const 成员函数</a>
</li>
<li><a href="#headline-6">避免在const和非const成员函数中的代码重复</a>
</li>
</ul>
</li>
<li><a href="#headline-7">Item 4: Make sure that objects are initialized before they&#39;re used</a>
</li>
</ul>
</li>
<li><a href="#headline-8">Ch-2</a>
<ul>
<li><a href="#headline-9">Item 5: Know what functions C++ silentlywrites and calls</a>
</li>
<li><a href="#headline-10">Item 6: Explicitly disallow the use of compiler-generated functions you do not want</a>
</li>
<li><a href="#headline-11">Item 7: Declare destructors virtual in polymorphic base classes</a>
</li>
<li><a href="#headline-12">Item 8: Prevent exceptions from leaving destructors</a>
</li>
<li><a href="#headline-13">Item 9: Never call virtual functions during construction or destruction</a>
</li>
<li><a href="#headline-14">Item 10: Have assignment operators return a reference to *this</a>
</li>
<li><a href="#headline-15">Item 11: Handle assignment to self in operator=</a>
</li>
<li><a href="#headline-16">Item 12: Copy all parts of an object</a>
</li>
</ul>
</li>
<li><a href="#headline-17">Ch-3 Resource Management</a>
<ul>
<li><a href="#headline-18">Item 13: Use objects to manage resources.</a>
</li>
<li><a href="#headline-19">Item 14: Think carefully about copying behavior in resource-managing classes.</a>
</li>
<li><a href="#headline-20">Item 15: Provide access to raw resources in resource-managing classes.</a>
</li>
<li><a href="#headline-21">Item 16: Use the same form in corresponding uses of new and delete.</a>
</li>
<li><a href="#headline-22">Item 17: Store newed objects in smart pointers in standalone statements.</a>
</li>
</ul>
</li>
<li><a href="#headline-23">Ch-4 Designs and Declarations</a>
<ul>
<li><a href="#headline-24">Item 18: Make interfaces easy to use correctly and hard to use incorrectly</a>
</li>
<li><a href="#headline-25">Item 19: Treat class design as type design</a>
<ul>
<li><a href="#headline-26">对象是如何创建和删除</a>
</li>
<li><a href="#headline-27">如何区分对象的初始化和赋值</a>
</li>
<li><a href="#headline-28">设计的对象按值传递时有什么含义</a>
</li>
<li><a href="#headline-29">类型对值的合法性作何限定</a>
</li>
<li><a href="#headline-30">类型是否适合继承图</a>
</li>
<li><a href="#headline-31">类型能够做哪些类型转换</a>
</li>
<li><a href="#headline-32">类型支持哪些操作符</a>
</li>
<li><a href="#headline-33">哪些标准函数需要禁用</a>
</li>
<li><a href="#headline-34">谁能够访问类型的成员</a>
</li>
<li><a href="#headline-35">类型有哪些隐性接口</a>
</li>
<li><a href="#headline-36">通用性怎么样</a>
</li>
<li><a href="#headline-37">真的需要一个新的类型</a>
</li>
</ul>
</li>
<li><a href="#headline-38">Item 20: Prefer pass-by-reference-to-const to pass-by-value</a>
</li>
<li><a href="#headline-39">Item 21: Don&#39;t try to return a reference when you must return an object</a>
</li>
<li><a href="#headline-40">Item 22: Declare data members private</a>
</li>
<li><a href="#headline-41">Item 23: Prefer non-member non-friend functions to member functions</a>
</li>
<li><a href="#headline-42">Item 24: Declare non-member functions when type conversions should apply to all parameters      </a>
</li>
<li><a href="#headline-43">Item 25: Consider support for a non-throwing swap</a>
</li>
</ul>
</li>
<li><a href="#headline-44">ch-5 Implementations</a>
<ul>
<li><a href="#headline-45">Item 26: Postpone variable definitions as long as possible  </a>
</li>
<li><a href="#headline-46">Item 27: Minimize casting</a>
</li>
<li><a href="#headline-47">Item 28: Avoid returning &#34;handles&#34; to object internals   </a>
</li>
<li><a href="#headline-48">Item29: Strive for exception-safe code.</a>
</li>
<li><a href="#headline-49">Item 30: Understand the ins and outs of inlining.</a>
</li>
<li><a href="#headline-50">Item31: Minimize compilation dependencies between files.</a>
</li>
</ul>
</li>
<li><a href="#headline-51">Ch-6. Inheritance and Object-Oriented Design</a>
<ul>
<li><a href="#headline-52">Item 32: Make sure public inheritance models &#34;is-a.&#34;</a>
</li>
<li><a href="#headline-53">Item 33: Avoid hiding inherited names</a>
</li>
<li><a href="#headline-54">Item 34: Differentiate between inheritance of interface and inheritance of implementation</a>
</li>
<li><a href="#headline-55">Item 35: Consider alternatives to virtual functions</a>
</li>
<li><a href="#headline-56">Item 36: Never redefine an inherited non-virtual function</a>
</li>
<li><a href="#headline-57">Item 37: Never redefine a function&#39;s inherited default parameter value</a>
</li>
<li><a href="#headline-58">Item 38: Model &#34;has-a&#34; or &#34;is-implemented-in-terms-of&#34; through composition</a>
</li>
<li><a href="#headline-59">Item 39: Use private inheritance judiciously</a>
</li>
<li><a href="#headline-60">Item 40: Use multiple inheritance judiciously   </a>
</li>
</ul>
</li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      
<blockquote>
<p>effecitve c++ 笔记</p>
</blockquote>
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
Ch-1
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<div id="outline-container-headline-2" class="outline-3">
<h3 id="headline-2">
Item 1: view C++ as a federation of languages
</h3>
<div id="outline-text-headline-2" class="outline-text-3">
<p>c++继承了c的部分，增加了面向对象的设计，增加了模板，以及标准模板库</p>
<p>
   这四个部分可以看做四种子语言，相对独立</p>
</div>
</div>
<div id="outline-container-headline-3" class="outline-3">
<h3 id="headline-3">
Item 2: Prefer consts, enums, and inlines to #defines
</h3>
<div id="outline-text-headline-3" class="outline-text-3">
<ul>
<li>
<p>使用const变量替换掉#define，后者只是做简单替换，对编译器透明，可能会导致生成重复对象代码(obj文件?)</p>
</li>
<li>
<p>相对于双重const的指针的char*字符串，更推荐使用const限定的string对象</p>
</li>
<li>
<p>类成员常量(部分如int, char, bool等内置类型)如果不被取址，可以只声明，不定义</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">GamePlayer</span> <span class="p">{</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">NumTurns</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// constant declaration
</span><span class="c1"></span>      <span class="kt">int</span> <span class="n">scores</span><span class="p">[</span><span class="n">NumTurns</span><span class="p">];</span> <span class="c1">// use of constant
</span><span class="c1"></span>  <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
如果需要取址，需要在实现文件中定义:</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">const</span> <span class="kt">int</span> <span class="n">GamePlayer</span><span class="o">::</span><span class="n">NumTruns</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
除此之外，可以使用枚举变量替换常量，以兼容一些老的编译器，以支持用作数组声明:</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">GamePlayer</span> <span class="p">{</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="k">enum</span> <span class="p">{</span> <span class="n">NumTurns</span> <span class="o">=</span> <span class="mi">5</span> <span class="p">};</span> <span class="c1">// &#34;the enum hack&#34; — makes
</span><span class="c1"></span>      <span class="c1">// NumTurns a symbolic name for 5
</span><span class="c1"></span>      <span class="kt">int</span> <span class="n">scores</span><span class="p">[</span><span class="n">NumTurns</span><span class="p">];</span> <span class="c1">// fine
</span><span class="c1"></span>  <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
</div>
</li>
<li>
<p>使用内联模板函数替代#define实现的宏函数，以降低复杂度</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-4" class="outline-3">
<h3 id="headline-4">
Item 3: Use const whenever possible
</h3>
<div id="outline-text-headline-4" class="outline-text-3">
<ul>
<li>
<p>指针*之前的cosnt限定指向的数据，*之后的const限定指针变量本身</p>
</li>
<li>
<p>迭代器的const等价于T* const，而const_iterator等价于const* T</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// OK, changes what iter points to
</span><span class="c1"></span>  <span class="o">++</span><span class="n">iter</span><span class="p">;</span> <span class="c1">// error! iter is const
</span><span class="c1"></span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">cIter</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="o">*</span><span class="n">cIter</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// error! *cIter is const
</span><span class="c1"></span>  <span class="o">++</span><span class="n">cIter</span><span class="p">;</span> <span class="c1">// fine, changes cIter
</span></code></pre></td></tr></table>
</div>
</div>
</div>
</li>
</ul>
<div id="outline-container-headline-5" class="outline-4">
<h4 id="headline-5">
const 成员函数
</h4>
<div id="outline-text-headline-5" class="outline-text-4">
<ul>
<li>
<p>bitwise constness(physical constness)含义是成员函数不应该修改对象的数据成员</p>
</li>
<li>
<p>logical constness在不违背逻辑的情况下，可以修改部分数据成员(使用mutable修饰)</p>
<p>
这两种constness是我们理解层面的概念，c++的const修饰符保证了大部分情况bitwise；如果要实现logical constness，需要使用mutable修饰符，让对应变量可以在const函数中被修改</p>
<p>
在一些不好的实现中，使用const修饰符还是不能保证bitwise:</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">CTextBlock</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">position</span><span class="p">)</span> <span class="k">const</span> 
      <span class="p">{</span>
          <span class="c1">// inappropriate (but bitwise const) 
</span><span class="c1"></span>          <span class="c1">// declaration of operator[]
</span><span class="c1"></span>          <span class="k">return</span> <span class="n">pText</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
      <span class="p">}</span>

  <span class="k">private</span><span class="o">:</span>
      <span class="kt">char</span> <span class="o">*</span><span class="n">pText</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">const</span> <span class="n">CTextBlock</span> <span class="nf">cctb</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">);</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cctb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="sc">&#39;J&#39;</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-6" class="outline-4">
<h4 id="headline-6">
避免在const和非const成员函数中的代码重复
</h4>
<div id="outline-text-headline-6" class="outline-text-4">
<p>很多时候我们需要分别实现const和non-const版本的成员函数，这里面可能包含很多重复代码(比如debug相关代码、日志代码、数据完整性验证)</p>
<p>
    通常情况下我们可以在non-const函数中调用const函数，反过来不行:</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">TextBlock</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>

  <span class="k">const</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">position</span><span class="p">)</span> <span class="k">const</span> <span class="c1">// same as before
</span><span class="c1"></span>  <span class="p">{</span>
      <span class="k">return</span> <span class="n">text</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">position</span><span class="p">)</span> <span class="c1">// now just calls const op[]
</span><span class="c1"></span>  <span class="p">{</span>
      <span class="k">return</span> 
          <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&amp;&gt;</span><span class="p">(</span> 
                            <span class="c1">// cast away const on
</span><span class="c1"></span>                            <span class="c1">// op[]&#39;s return type;
</span><span class="c1"></span>                            <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">TextBlock</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)[</span><span class="n">position</span><span class="p">]</span>
                            <span class="c1">// add const to *this&#39;s type;
</span><span class="c1"></span>                            <span class="c1">// call const version of op[]
</span><span class="c1"></span>                             <span class="p">);</span>
  <span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-7" class="outline-3">
<h3 id="headline-7">
Item 4: Make sure that objects are initialized before they&#39;re used
</h3>
<div id="outline-text-headline-7" class="outline-text-3">
<ul>
<li>
<p>为简单处理，所有的变量都需要初始化，优先使用构造函数列表来初始化成员函数(老的编译器需要程序员保证顺序)</p>
</li>
<li>
<p>函数内的static变量可以当做单例使用</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-8" class="outline-2">
<h2 id="headline-8">
Ch-2
</h2>
<div id="outline-text-headline-8" class="outline-text-2">
<div id="outline-container-headline-9" class="outline-3">
<h3 id="headline-9">
Item 5: Know what functions C++ silentlywrites and calls
</h3>
<div id="outline-text-headline-9" class="outline-text-3">
<p>如果没有声明，编译器会隐式生成构造、拷贝构造和析构函数。但如果遇到一些意外情况，编译器会报错：</p>
<ul>
<li>
<p>成员变量是引用或者带有const修饰，不会生成拷贝构造函数</p>
</li>
<li>
<p>基类拷贝构造函数被声明为private</p>
</li>
<li>
<p>等等</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-10" class="outline-3">
<h3 id="headline-10">
Item 6: Explicitly disallow the use of compiler-generated functions you do not want
</h3>
<div id="outline-text-headline-10" class="outline-text-3">
<p>
   如果不希望编译器自动生成部分函数，可以在private下面声明他们，然后不实现</p>
<p>
   特别的，如果一个类不希望被拷贝，可以考虑私有继承 <em>Uncopyable</em> 类:</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">Uncopyable</span> <span class="p">{</span>
  <span class="k">protected</span><span class="o">:</span> <span class="c1">// allow construction
</span><span class="c1"></span>      <span class="n">Uncopyable</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// and destruction of
</span><span class="c1"></span>      <span class="o">~</span><span class="n">Uncopyable</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// derived objects...
</span><span class="c1"></span>  <span class="k">private</span><span class="o">:</span>
      <span class="n">Uncopyable</span><span class="p">(</span><span class="k">const</span> <span class="n">Uncopyable</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// ...but prevent copying
</span><span class="c1"></span>      <span class="n">Uncopyable</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Uncopyable</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-11" class="outline-3">
<h3 id="headline-11">
Item 7: Declare destructors virtual in polymorphic base classes
</h3>
<div id="outline-text-headline-11" class="outline-text-3">
<ul>
<li>
<p>需要用作多态的类型的类需要虚析构函数</p>
</li>
<li>
<p>不用于派生的类不建议使用虚析构函数，一方面增加了一个虚表的开销，另一方面数据结构和c等外部语言不兼容</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-12" class="outline-3">
<h3 id="headline-12">
Item 8: Prevent exceptions from leaving destructors
</h3>
<div id="outline-text-headline-12" class="outline-text-3">
<ul>
<li>
<p>析构函数不应该异常，如果发生了，要么终止程序，要么吞掉所以异常</p>
</li>
<li>
<p>某些可能抛异常的清理操作尽量放在独立的函数(类似于close或者destroy这样的)，由外部调用并处理异常</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-13" class="outline-3">
<h3 id="headline-13">
Item 9: Never call virtual functions during construction or destruction
</h3>
<div id="outline-text-headline-13" class="outline-text-3">
<p>对象构造和析构的时候调用虚函数会存在无定义行为，通常这种需求可以转换为在构造时传递参数或者使用对应类的静态构建函数</p>
</div>
</div>
<div id="outline-container-headline-14" class="outline-3">
<h3 id="headline-14">
Item 10: Have assignment operators return a reference to *this
</h3>
<div id="outline-text-headline-14" class="outline-text-3">
<p>赋值操作符最好返回*this(所有内置类型都遵守这个惯例)，连等的操作就是通过这样实现的</p>
</div>
</div>
<div id="outline-container-headline-15" class="outline-3">
<h3 id="headline-15">
Item 11: Handle assignment to self in operator=
</h3>
<div id="outline-text-headline-15" class="outline-text-3">
<p>赋值操作符需要考虑到自我赋值的情况，一般来说构建一个临时变量，然后swap</p>
<p>
   也可以做分支判断，如果是自己就直接返回。但一般这种操作是低频的，而且会带来取址、缓存命中和管线的开销。</p>
</div>
</div>
<div id="outline-container-headline-16" class="outline-3">
<h3 id="headline-16">
Item 12: Copy all parts of an object
</h3>
<div id="outline-text-headline-16" class="outline-text-3">
<p>拷贝函数包括构造拷贝函数和赋值操作符，如果要自己实现拷贝函数，需要覆盖掉所有可能的情况(特别是在后面增加成员的时候)，编译器是不会报错的</p>
<p>
   两个拷贝函数无法相互调用，要实现代码复用，只能在增加一个private的公共代码函数</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-17" class="outline-2">
<h2 id="headline-17">
Ch-3 Resource Management
</h2>
<div id="outline-text-headline-17" class="outline-text-2">
<p>资源就是一种一旦你使用了，就需要返回(给系统)的东西。如果不还，就会出问题</p>
<div id="outline-container-headline-18" class="outline-3">
<h3 id="headline-18">
Item 13: Use objects to manage resources.
</h3>
<div id="outline-text-headline-18" class="outline-text-3">
<p>
   通常从API申请到资源之后，返回的是指针(或者句柄)，例如：</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="n">Investment</span> <span class="o">*</span><span class="n">pInv</span> <span class="o">=</span> <span class="n">createInvestment</span><span class="p">();</span> <span class="c1">// call factory function
</span><span class="c1"></span>      <span class="c1">// use pInv
</span><span class="c1"></span>      <span class="k">delete</span> <span class="n">pInv</span><span class="p">;</span> <span class="c1">// release object
</span><span class="c1"></span>  <span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   函数f中第一行申请了pInv，最后一行释放了pInv。在中间的使用过程中，如果出现了异常，最后一行可能执行不到，一个比较好的办法就是把pInv放到局部对象来管理，在栈清理时候自动调用对象析构释放资源，auto_ptr就是这个作用：</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">Investment</span><span class="o">&gt;</span> <span class="n">pInv</span><span class="p">(</span><span class="n">createInvestment</span><span class="p">());</span> <span class="c1">// call factory
</span><span class="c1"></span>      <span class="c1">// function
</span><span class="c1"></span>      <span class="p">...</span> <span class="c1">// use pInv as
</span><span class="c1"></span>      <span class="c1">// before
</span><span class="c1"></span>  <span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   由于auto_ptr在拷贝时候的语义很奇怪，后面被废弃了，而是使用unique_ptr替代，unique_ptr不允许拷贝，只允许使用std::move显式转移，并且支持deleter和数组</p>
<p>
   这种资源管理方式经常叫做RAII(<em>Resource Acquisition Is Initialization</em>)</p>
<p>
   unique_ptr独占一个资源，如果要共享，可以使用shared_ptr。shared_ptr使用引用计数来维护声明周期，在引用计数降为0时，调用deleter</p>
<p>
   引用计数会带来循环引用的问题，所以可以考虑使用弱引用(weak_ptr)来解决，weak_ptr在使用时必须先转为shared_ptr</p>
</div>
</div>
<div id="outline-container-headline-19" class="outline-3">
<h3 id="headline-19">
Item 14: Think carefully about copying behavior in resource-managing classes.
</h3>
<div id="outline-text-headline-19" class="outline-text-3">
<p>一般来说涉及资源管理拷贝的情况分为四种：</p>
<ul>
<li>
<p>禁止拷贝
比如说锁，拿到一把锁之后，极少可能性会把锁的资源管理类进行复制：</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">Lock</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">Lock</span><span class="p">(</span><span class="n">Mutex</span> <span class="o">*</span><span class="n">pm</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">mutexPtr</span><span class="p">(</span><span class="n">pm</span><span class="p">)</span>
      <span class="p">{</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutexPtr</span><span class="p">);</span> <span class="p">}</span> <span class="c1">// acquire resource
</span><span class="c1"></span>      <span class="o">~</span><span class="n">Lock</span><span class="p">()</span> <span class="p">{</span> <span class="n">unlock</span><span class="p">(</span><span class="n">mutexPtr</span><span class="p">);</span> <span class="p">}</span> <span class="c1">// release resource
</span><span class="c1"></span>  <span class="k">private</span><span class="o">:</span>
      <span class="n">Mutex</span> <span class="o">*</span><span class="n">mutexPtr</span><span class="p">;</span>
  <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
</div>
</li>
<li>
<p>对下层资源计算引用计数
当拷贝资源管理类时，增加一个引用计数，类似于shared_ptr。当引用计数降为0时，调用deleter做清理操作</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">Lock</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="k">explicit</span> <span class="n">Lock</span><span class="p">(</span><span class="n">Mutex</span> <span class="o">*</span><span class="n">pm</span><span class="p">)</span> <span class="c1">// init shared_ptr with the Mutex
</span><span class="c1"></span>          <span class="o">:</span> <span class="n">mutexPtr</span><span class="p">(</span><span class="n">pm</span><span class="p">,</span> <span class="n">unlock</span><span class="p">)</span> <span class="c1">// to point to and the unlock func
</span><span class="c1"></span>      <span class="p">{</span> <span class="c1">// as the deleter
</span><span class="c1"></span>          <span class="n">lock</span><span class="p">(</span><span class="n">mutexPtr</span><span class="p">.</span><span class="n">get</span><span class="p">());</span> <span class="c1">// see Item 15 for info on &#34;get&#34;
</span><span class="c1"></span>      <span class="p">}</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="n">std</span><span class="o">::</span><span class="n">tr1</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&gt;</span> <span class="n">mutexPtr</span><span class="p">;</span> <span class="c1">// use shared_ptr
</span><span class="c1"></span>  <span class="p">};</span> <span class="c1">// instead of raw pointer
</span></code></pre></td></tr></table>
</div>
</div>
</div>
</li>
<li>
<p>拷贝下层资源
如果希望复制多份资源时候，就需要拷贝下层资源，各个资源管理类需要自行清理掉自己管理的资源副本，简称“深拷贝”，std::string就是这样做的</p>
</li>
<li>
<p>转移下层资源的拥有权
类似于auto_ptr或者unique_ptr这样的独占管理类</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-20" class="outline-3">
<h3 id="headline-20">
Item 15: Provide access to raw resources in resource-managing classes.
</h3>
<div id="outline-text-headline-20" class="outline-text-3">
<p>资源管理类都会提供API访问下层资源，c++支持显式或者隐式，前者安全，后者方便：</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">Font</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="k">operator</span> <span class="n">FontHandle</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">f</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// implicit conversion function
</span><span class="c1"></span>  <span class="k">private</span><span class="o">:</span>
      <span class="n">FontHandle</span> <span class="n">f</span><span class="p">;</span> <span class="c1">// the raw font resource
</span><span class="c1"></span><span class="err"> </span>
  <span class="p">};</span>

  <span class="n">Font</span> <span class="nf">f1</span><span class="p">(</span><span class="n">getFont</span><span class="p">());</span>

  <span class="n">FontHandle</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">f1</span><span class="p">;</span> <span class="c1">// oops! meant to copy a Font
</span><span class="c1"></span>  <span class="c1">// object, but instead implicitly
</span><span class="c1"></span>  <span class="c1">// converted f1 into its underlying
</span><span class="c1"></span>  <span class="c1">// FontHandle, then copied that
</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   f1被清理的时候，会释放掉底层资源，也就是f2会变成野指针</p>
</div>
</div>
<div id="outline-container-headline-21" class="outline-3">
<h3 id="headline-21">
Item 16: Use the same form in corresponding uses of new and delete.
</h3>
<div id="outline-text-headline-21" class="outline-text-3">
<p>new/delete和new []/delete []成对使用</p>
</div>
</div>
<div id="outline-container-headline-22" class="outline-3">
<h3 id="headline-22">
Item 17: Store newed objects in smart pointers in standalone statements.
</h3>
<div id="outline-text-headline-22" class="outline-text-3">
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="n">processWidget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">),</span> <span class="n">priority</span><span class="p">());</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   以上代码可能会出现内存泄露的风险：</p>
<ol>
<li>
<p>执行new Widget</p>
</li>
<li>
<p>调用priority()</p>
</li>
<li>
<p>调用std::shared_ptr</p>
</li>
</ol>
<p>如果在第二步出现异常，会导致第一步申请的资源得不到释放。其原因还是在于c++没有定义代码执行的顺序，保险的方案是把资源申请独立出来：</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">pw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">);</span> <span class="c1">// store newed object
</span><span class="c1"></span>  <span class="c1">// in a smart pointer in a
</span><span class="c1"></span>  <span class="c1">// standalone statement
</span><span class="c1"></span>  <span class="n">processWidget</span><span class="p">(</span><span class="n">pw</span><span class="p">,</span> <span class="n">priority</span><span class="p">());</span> <span class="c1">// this call won&#39;t leak
</span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-23" class="outline-2">
<h2 id="headline-23">
Ch-4 Designs and Declarations
</h2>
<div id="outline-text-headline-23" class="outline-text-2">
<p>
  本章主要讲述c++类型设计和声明</p>
<div id="outline-container-headline-24" class="outline-3">
<h3 id="headline-24">
Item 18: Make interfaces easy to use correctly and hard to use incorrectly
</h3>
<div id="outline-text-headline-24" class="outline-text-3">
<ul>
<li>
<p>接口使用专用类型，而不是简单的int等内置类型</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">Date</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">Date</span><span class="p">(</span><span class="kt">int</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int</span> <span class="n">day</span><span class="p">,</span> <span class="kt">int</span> <span class="n">year</span><span class="p">);</span>
      <span class="p">...</span>
  <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
</div>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">Date</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">Date</span><span class="p">(</span><span class="k">const</span> <span class="n">Month</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">Day</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">,</span> <span class="k">const</span> <span class="n">Year</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">);</span>
      <span class="p">...</span>
  <span class="p">};</span>
  <span class="n">Date</span> <span class="nf">d</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1995</span><span class="p">);</span> <span class="c1">// error! wrong types
</span><span class="c1"></span>  <span class="n">Date</span> <span class="nf">d</span><span class="p">(</span><span class="n">Day</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">Month</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">Year</span><span class="p">(</span><span class="mi">1995</span><span class="p">));</span> <span class="c1">// error! wrong types
</span><span class="c1"></span>  <span class="n">Date</span> <span class="nf">d</span><span class="p">(</span><span class="n">Month</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">Day</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">Year</span><span class="p">(</span><span class="mi">1995</span><span class="p">));</span> <span class="c1">// okay, types are correct
</span></code></pre></td></tr></table>
</div>
</div>
</div>
</li>
<li>
<p>shared_ptr之类的deleter可以避免跨dll时new/delete不一致导致的问题</p>
</li>
<li>
<p>factory创建对象时候，直接返回智能指针而不是裸指针可以减少用户手动RAII的工作量</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-25" class="outline-3">
<h3 id="headline-25">
Item 19: Treat class design as type design
</h3>
<div id="outline-text-headline-25" class="outline-text-3">
<p>类的设计相当于类型设计，需要考虑到一下一些因素：</p>
<div id="outline-container-headline-26" class="outline-4">
<h4 id="headline-26">
对象是如何创建和删除
</h4>
<div id="outline-text-headline-26" class="outline-text-4">
<p>这将影响到构造和析构函数的设计，也影响到内存分配的选择</p>
</div>
</div>
<div id="outline-container-headline-27" class="outline-4">
<h4 id="headline-27">
如何区分对象的初始化和赋值
</h4>
<div id="outline-text-headline-27" class="outline-text-4">
<p>这个区别实际上就是构造函数和拷贝函数的区别</p>
</div>
</div>
<div id="outline-container-headline-28" class="outline-4">
<h4 id="headline-28">
设计的对象按值传递时有什么含义
</h4>
<div id="outline-text-headline-28" class="outline-text-4">
<p>拷贝构造函数决定了按值传递的实现</p>
</div>
</div>
<div id="outline-container-headline-29" class="outline-4">
<h4 id="headline-29">
类型对值的合法性作何限定
</h4>
<div id="outline-text-headline-29" class="outline-text-4">
<p>数据成员的值组合，只有一部分是合法的，这些组合决定了类型需要维护的不变量，而这些不变量决定了怎样做错误检查，并影响异常的实现</p>
</div>
</div>
<div id="outline-container-headline-30" class="outline-4">
<h4 id="headline-30">
类型是否适合继承图
</h4>
<div id="outline-text-headline-30" class="outline-text-4">
<p>如果继承于已有的类，这些类会有一些束缚，例如它们的函数是否虚化？如果允许别的类继承自己的类，自身的函数是否要虚化，尤其是析构函数？</p>
</div>
</div>
<div id="outline-container-headline-31" class="outline-4">
<h4 id="headline-31">
类型能够做哪些类型转换
</h4>
<div id="outline-text-headline-31" class="outline-text-4">
<p>能否转换？隐式的？显式的？</p>
</div>
</div>
<div id="outline-container-headline-32" class="outline-4">
<h4 id="headline-32">
类型支持哪些操作符
</h4>
<div id="outline-text-headline-32" class="outline-text-4">
<p>+,-,*,/……</p>
</div>
</div>
<div id="outline-container-headline-33" class="outline-4">
<h4 id="headline-33">
哪些标准函数需要禁用
</h4>
<div id="outline-text-headline-33" class="outline-text-4">
<p>声明为private并只做声明不实现</p>
</div>
</div>
<div id="outline-container-headline-34" class="outline-4">
<h4 id="headline-34">
谁能够访问类型的成员
</h4>
<div id="outline-text-headline-34" class="outline-text-4">
<p>这将决定public、protected和private的使用</p>
</div>
</div>
<div id="outline-container-headline-35" class="outline-4">
<h4 id="headline-35">
类型有哪些隐性接口
</h4>
<div id="outline-text-headline-35" class="outline-text-4">
<p>例如提供了哪些保证(guarantees)，包括对性能、异常安全以及资源使用(锁、动态内存分配)，这些保证将是在实现时候的约束</p>
</div>
</div>
<div id="outline-container-headline-36" class="outline-4">
<h4 id="headline-36">
通用性怎么样
</h4>
<div id="outline-text-headline-36" class="outline-text-4">
<p>是否考虑用模板</p>
</div>
</div>
<div id="outline-container-headline-37" class="outline-4">
<h4 id="headline-37">
真的需要一个新的类型
</h4>
<div id="outline-text-headline-37" class="outline-text-4">
<p>也许只需要定义成非成员函数或者模板就能实现？</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-38" class="outline-3">
<h3 id="headline-38">
Item 20: Prefer pass-by-reference-to-const to pass-by-value
</h3>
<div id="outline-text-headline-38" class="outline-text-3">
<ul>
<li>
<p>自定义类型即便很小，也建议传const引用，因为自定义变量很可能随着时间有变化</p>
</li>
<li>
<p>传引用(指针)一定能够放到寄存器的，而其他类型不一定了(看编译器)</p>
</li>
<li>
<p>对于内置类型、STL迭代器和函数对象类型，传值更合适</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-39" class="outline-3">
<h3 id="headline-39">
Item 21: Don&#39;t try to return a reference when you must return an object
</h3>
<div id="outline-text-headline-39" class="outline-text-3">
<p>避免返回栈上对象的引用、函数静态成员以及new出来的对象</p>
</div>
</div>
<div id="outline-container-headline-40" class="outline-3">
<h3 id="headline-40">
Item 22: Declare data members private
</h3>
<div id="outline-text-headline-40" class="outline-text-3">
<ul>
<li>
<p>unencapsulated means unchangeable</p>
</li>
<li>
<p>protected成员也是违背封装的，跟public一样</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-41" class="outline-3">
<h3 id="headline-41">
Item 23: Prefer non-member non-friend functions to member functions
</h3>
<div id="outline-text-headline-41" class="outline-text-3">
<ul>
<li>
<p>非友元并且非成员函数不会增加访问私有变量的接口，提高了封装性，注意一定是非友元并且非成员</p>
</li>
<li>
<p>这种函数一般都属于 <em>convenience functions</em> ，即便没有这些函数，用户可以组合成员函数来实现功能</p>
</li>
<li>
<p>对c++来说，这样的函数往往可以写到命名空间里面，然后按功能放在不同的头文件里面，提供了强大的可扩展性。很多标准库就是这样组织的，使用成员函数无法实现这种组织方式</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-42" class="outline-3">
<h3 id="headline-42">
Item 24: Declare non-member functions when type conversions should apply to all parameters      
</h3>
<div id="outline-text-headline-42" class="outline-text-3">
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">const</span> <span class="n">Rational</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="c1">// now a non-member
</span><span class="c1"></span>                           <span class="k">const</span> <span class="n">Rational</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="c1">// function
</span><span class="c1"></span>  <span class="p">{</span>
      <span class="k">return</span> <span class="nf">Rational</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">numerator</span><span class="p">()</span> <span class="o">*</span> <span class="n">rhs</span><span class="p">.</span><span class="n">numerator</span><span class="p">(),</span>
                      <span class="n">lhs</span><span class="p">.</span><span class="n">denominator</span><span class="p">()</span> <span class="o">*</span> <span class="n">rhs</span><span class="p">.</span><span class="n">denominator</span><span class="p">());</span>
  <span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   如果*操作符作为Raitonal的成员函数，第一个参数就定死为this了，无法处理int * Ratinal的情况，除此之外，不必是友元函数。</p>
</div>
</div>
<div id="outline-container-headline-43" class="outline-3">
<h3 id="headline-43">
Item 25: Consider support for a non-throwing swap
</h3>
<div id="outline-text-headline-43" class="outline-text-3">
<p>要实现一个自定义swap，三步：</p>
<ol>
<li>
<p>写一个交换数据用的成员函数</p>
</li>
<li>
<p>在当前同一个命名空间里面提供一个非成员版的swap函数</p>
</li>
<li>
<p>如果swap一个类(非类模板)，特化std::swap，让它调用已实现的swap成员函数</p>
</li>
</ol>
<p>需要注意swap不能抛异常</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-44" class="outline-2">
<h2 id="headline-44">
ch-5 Implementations
</h2>
<div id="outline-text-headline-44" class="outline-text-2">
<div id="outline-container-headline-45" class="outline-3">
<h3 id="headline-45">
Item 26: Postpone variable definitions as long as possible  
</h3>
<div id="outline-text-headline-45" class="outline-text-3">
<p>一些局部变量放到需要的时候才初始化，避免不必要的构造开销</p>
<p>
   循环变量的定义位置跟构造函数和赋值操作的性能相关，如果构造的开销小于赋值，则放在里面</p>
</div>
</div>
<div id="outline-container-headline-46" class="outline-3">
<h3 id="headline-46">
Item 27: Minimize casting
</h3>
<div id="outline-text-headline-46" class="outline-text-3">
<p>几种cast:</p>
<ol>
<li>
<p><em>const_cast</em> 用来去掉const属性，其他cast都不行</p>
</li>
<li>
<p><em>dynamic_cast</em> 一般用来将基类安全地转换为派生类，有较大的运行时开销</p>
</li>
<li>
<p><em>reinterpret_cast</em> 下层转换，常用来把指针转为int，高级代码尽量不要用</p>
</li>
<li>
<p><em>static_cast</em> 用于强制隐式转换</p>
</li>
</ol>
<p>旧的转换方案也是可以用的，一般用于函数传参。新的cast一方面方便grep查找，另一方面便于编译器优化</p>
<p>
   cast方案可能会被误用：</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">Window</span> <span class="p">{</span> <span class="c1">// base class
</span><span class="c1"></span>  <span class="k">public</span><span class="o">:</span>
      <span class="k">virtual</span> <span class="kt">void</span> <span class="n">onResize</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// base onResize impl
</span><span class="c1"></span>      <span class="p">...</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">SpecialWindow</span><span class="o">:</span> <span class="k">public</span> <span class="n">Window</span>
  <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="k">virtual</span> <span class="kt">void</span> <span class="n">onResize</span><span class="p">()</span> <span class="p">{</span>
          <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Window</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">onResize</span><span class="p">();</span> <span class="c1">// doesn&#39;t work!
</span><span class="c1"></span>          <span class="p">...</span>
      <span class="p">}</span>
      <span class="p">...</span>
  <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   这里使用static_cast实际上创建了一个临时对象，复制了一份*this，正确方法应该是：</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">SpecialWindow</span><span class="o">:</span> <span class="k">public</span> <span class="n">Window</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="k">virtual</span> <span class="kt">void</span> <span class="n">onResize</span><span class="p">()</span> <span class="p">{</span>
          <span class="n">Window</span><span class="o">::</span><span class="n">onResize</span><span class="p">();</span> <span class="c1">// call Window::onResize
</span><span class="c1"></span>          <span class="p">...</span> <span class="c1">// on *this
</span><span class="c1"></span>      <span class="p">}</span>
      <span class="p">...</span>
  <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   如果这里用指针，会有无限递归的问题</p>
<p>
   dynamic_cast可以通过容器或者虚函数来避免，一定不要写出级联的dynamic_cast代码:</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tr1</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Window</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">VPW</span><span class="p">;</span>
  <span class="n">VPW</span> <span class="n">winPtrs</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">VPW</span><span class="o">::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">winPtrs</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">winPtrs</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">SpecialWindow1</span> <span class="o">*</span><span class="n">psw1</span> <span class="o">=</span> 
          <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">SpecialWindow1</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
      <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">SpecialWindow2</span> <span class="o">*</span><span class="n">psw2</span> <span class="o">=</span>
               <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">SpecialWindow2</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
      <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">SpecialWindow3</span> <span class="o">*</span><span class="n">psw3</span> <span class="o">=</span>
               <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">SpecialWindow3</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
   <span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
</div>
<ul>
<li>
<p>尽量避免转换，特别是 <em>dynamic_cast</em></p>
</li>
<li>
<p>如果一定要做转换，尽量隐藏到函数中，而不是让客户代码自己做转换</p>
</li>
<li>
<p>优先使用c++风格的转换，更加明确</p>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-47" class="outline-3">
<h3 id="headline-47">
Item 28: Avoid returning &#34;handles&#34; to object internals   
</h3>
<div id="outline-text-headline-47" class="outline-text-3">
<p>不要返回任何对象内部的句柄(引用、指针或者迭代器)，一方面破坏封装，另一方面生命周期不可预期。</p>
</div>
</div>
<div id="outline-container-headline-48" class="outline-3">
<h3 id="headline-48">
Item29: Strive for exception-safe code.
</h3>
<div id="outline-text-headline-48" class="outline-text-3">
<p>尽量写异常安全代码，异常安全有三个级别：</p>
<ul>
<li>
<p><em><strong>the basic guarantee</strong></em>: 如果发生异常，程序还是一个合法的状态，但是状态不可预期</p>
</li>
<li>
<p><em><strong>the strong guarantee</strong></em>: 完全成功或者完全失败，类似于原子操作</p>
</li>
<li>
<p><em><strong>the nothrow guarantee</strong></em>: 永不抛异常</p>
</li>
</ul>
<p>异常安全代码至少要保证以上至少一项，难度依次递增</p>
<p>
   <em>the strong guarantee</em> 函数通常可以使用 <em>copy-and-swap</em> 的方式来实现</p>
<p>
   在写异常安全函数中，如果调用了其他函数，一般要求安全等级不低于当前函数，不然很难保证安全。</p>
<p>
   如果函数调用了很多不同异常安全等级的子函数，该函数的安全等级不会高于最低的子函数</p>
</div>
</div>
<div id="outline-container-headline-49" class="outline-3">
<h3 id="headline-49">
Item 30: Understand the ins and outs of inlining.
</h3>
<div id="outline-text-headline-49" class="outline-text-3">
<p>只在真正有需要的地方，对函数进行内联，避免滥用</p>
<p>
   inline函数一旦发布出去，后期有修改的话，所有调用到该函数的代码都需要重新编译</p>
</div>
</div>
<div id="outline-container-headline-50" class="outline-3">
<h3 id="headline-50">
Item31: Minimize compilation dependencies between files.
</h3>
<div id="outline-text-headline-50" class="outline-text-3">
<p>默认c++类对接口和实现的分离做得并不好</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">Person</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">Date</span><span class="o">&amp;</span> <span class="n">birthday</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">Address</span><span class="o">&amp;</span> <span class="n">addr</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">birthDate</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">address</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">private</span><span class="o">:</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">theName</span><span class="p">;</span> <span class="c1">// implementation detail
</span><span class="c1"></span>      <span class="n">Date</span> <span class="n">theBirthDate</span><span class="p">;</span> <span class="c1">// implementation detail
</span><span class="c1"></span>      <span class="n">Address</span> <span class="n">theAddress</span><span class="p">;</span> <span class="c1">// implementation detail
</span><span class="c1"></span>  <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   这几个私有成员往往会要求include自己的头文件，比如 <em>&lt;string&gt;</em>, <em>date.h</em>, <em>address.h</em> 之类的，
   一旦这些头文件有改动，Person类以及使用Person类的文件都会重编译</p>
<p>
   当然可以用 <em>forward declaration</em> 的方式来避免include头文件，但是会带来两个问题：</p>
<ol>
<li>
<p>string是一个typedef，不能预先声明</p>
</li>
<li>
<p>如果要定义，会涉及分配空间的问题，编译器不能决定该分配多少空间</p>
</li>
</ol>
<p>解决这个问题的方法就是把Person写成句柄类：</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="cp">#include</span> <span class="cpf">&lt;string&gt; // standard library components shouldn&#39;t be forward-declared</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;memory&gt; // for tr1::shared_ptr; see below</span><span class="cp">
</span><span class="cp"></span>
  <span class="k">class</span> <span class="nc">PersonImpl</span><span class="p">;</span> <span class="c1">// forward decl of Person impl. class
</span><span class="c1"></span>  <span class="k">class</span> <span class="nc">Date</span><span class="p">;</span>       <span class="c1">// forward decls of classes used in
</span><span class="c1"></span>  <span class="k">class</span> <span class="nc">Address</span><span class="p">;</span>    <span class="c1">// Person interface
</span><span class="c1"></span>
  <span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="n">Person</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">Date</span><span class="o">&amp;</span> <span class="n">birthday</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">Address</span><span class="o">&amp;</span> <span class="n">addr</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">birthDate</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">address</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">private</span><span class="o">:</span>
      <span class="n">std</span><span class="o">::</span><span class="n">tr1</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">PersonImpl</span><span class="o">&gt;</span> <span class="n">pImpl</span><span class="p">;</span>
 
  <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   在PersonImpl类里面做真正的实现，接口一一对应。</p>
<p>
   实现分离的关键在于将对定义的依赖，替换为对声明的依赖。可能的话，尽量让头文件自我依赖；如果做不到，也只依赖于其他文件的声明，而不是定义</p>
<p>
   遵循以下原则：</p>
<ul>
<li>
<p>在可以用指针或者引用的情况下，尽量避免直接使用对象</p>
</li>
<li>
<p>只要可能，依赖类的声明而不是类的定义
声明一个函数是不需要定义的：</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">Date</span><span class="p">;</span>

  <span class="n">Date</span> <span class="nf">today</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">clearAppointmets</span><span class="p">(</span><span class="n">Date</span> <span class="n">d</span><span class="p">);</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
以上Date未定义，但是依然是合法的，只有在真正需要的地方，再include必要的定义</p>
</li>
<li>
<p>对定义和声明提供分开的两份头文件，两份文件保持一致
使用库的客户需要include声明文件，而不是手动 <em>forward declare</em></p>
</li>
</ul>
<p>另一种方法，是让Person成为一个抽象基类，也就是接口类。相对于.net或者java，c++的接口类可以支持实现一些非虚函数，以便所有继承类能够使用</p>
<p>
   客户可以调用静态 <em>factory</em> 函数来构建Person子类，并返回指针。</p>
<p>
   句柄类和接口类都解决了声明和定义的耦合问题，代价就是多一级访问的开销，这两种方法都不能使用inline(inline会把头文件的代码插入到所有调用的地方)</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-51" class="outline-2">
<h2 id="headline-51">
Ch-6. Inheritance and Object-Oriented Design
</h2>
<div id="outline-text-headline-51" class="outline-text-2">
<div id="outline-container-headline-52" class="outline-3">
<h3 id="headline-52">
Item 32: Make sure public inheritance models &#34;is-a.&#34;
</h3>
<div id="outline-text-headline-52" class="outline-text-3">
<p>
   public继承最关键的一点: <em><strong>is-a</strong></em></p>
<p>
   一些生活中的概念并不能直接建模，它们并不满足 <em>is-a</em> 的原则：企鹅不能公有继承鸟(鸟会飞)，正方形不能公有继承长方形(长方形允许调整单边长度)</p>
<p>
   public继承要求，任何基类的方法，都能够无歧义地应用到派生类</p>
</div>
</div>
<div id="outline-container-headline-53" class="outline-3">
<h3 id="headline-53">
Item 33: Avoid hiding inherited names
</h3>
<div id="outline-text-headline-53" class="outline-text-3">
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="k">virtual</span> <span class="kt">void</span> <span class="n">mf1</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">mf1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
      <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">mf2</span><span class="p">();</span>
      <span class="kt">void</span> <span class="nf">mf3</span><span class="p">();</span>
      <span class="kt">void</span> <span class="nf">mf3</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>

  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="k">virtual</span> <span class="kt">void</span> <span class="n">mf1</span><span class="p">();</span>
      <span class="kt">void</span> <span class="nf">mf3</span><span class="p">();</span>
      <span class="kt">void</span> <span class="nf">mf4</span><span class="p">();</span>
  <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>上面代码中，派生类的mf1和mf3名称会隐藏掉基类的名称，以下代码是编译不过的：</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>

  <span class="n">d</span><span class="p">.</span><span class="n">mf1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="n">d</span><span class="p">.</span><span class="n">mf4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   即便不用不合法的调用，如果不继承基类的重载函数，也是违背了public继承的 <em>is-a</em> 原则。解决办法就是在public下面使用using Base::mf1和using Base::mf3将对应的名称暴露出来。</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">mf1</span><span class="p">;</span> <span class="c1">// make all things in Base named mf1 and mf3
</span><span class="c1"></span>      <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">mf3</span><span class="p">;</span> <span class="c1">// visible (and public) in Derived&#39;s scope
</span><span class="c1"></span>      <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">mf1</span><span class="p">();</span>
      <span class="kt">void</span> <span class="nf">mf3</span><span class="p">();</span>
      <span class="kt">void</span> <span class="nf">mf4</span><span class="p">();</span>
  <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   但是在私有继承的时候，可能需要暴露一部分基类的名称到public里面，如果用using，会导致所有的基类名称都暴露出去了，这里可以考虑forwarding function</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">private</span> <span class="n">Base</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="k">virtual</span> <span class="kt">void</span> <span class="n">mf1</span><span class="p">()</span> <span class="c1">// forwarding function; implicitly
</span><span class="c1"></span>      <span class="p">{</span> <span class="n">Base</span><span class="o">::</span><span class="n">mf1</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// inline (see Item 30)
</span><span class="c1"></span>
  <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   PS：using是受public和private的限制的</p>
</div>
</div>
<div id="outline-container-headline-54" class="outline-3">
<h3 id="headline-54">
Item 34: Differentiate between inheritance of interface and inheritance of implementation
</h3>
<div id="outline-text-headline-54" class="outline-text-3">
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="k">virtual</span> <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">error</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">);</span>
      <span class="kt">int</span> <span class="nf">objectID</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   一般来说，继承包含三种，如上面代码：</p>
<ol>
<li>
<p>继承接口</p>
<p>
基类的纯虚函数，必须由派生类实现，纯虚函数只用来指定接口。</p>
<p>
此时基类也可以写一个同名的默认实现(不会被继承，也无法被默认使用)，派生类调用Base::xxx()来使用，这样要求派生类显式调用，可以避免增加一些有变化的派生类时，忘了重写默认函数</p>
</li>
<li>
<p>继承实现</p>
<p>
基类的普通虚函数，派生类继承接口和一个默认的实现</p>
</li>
<li>
<p>非虚函数</p>
<p>
指定了接口，并且带上一个强制不变的实现</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-55" class="outline-3">
<h3 id="headline-55">
Item 35: Consider alternatives to virtual functions
</h3>
<div id="outline-text-headline-55" class="outline-text-3">
<p>虚函数有很多替代的方案</p>
<ol>
<li>
<p><strong>non-vertual interface idiom</strong> (NVI idiom)    </p>
<p>
public接口使用非虚函数实现，通过调用真正有功能的虚函数来实现多态，相当于wrapper。</p>
<p>
可以为private，派生类虽然无法调用这些虚函数(private)，但是可以重载，这里不冲突。重定义一个虚函数决定了 <em>how something is to be done</em> ，而调用一个虚函数，决定了 <em>when it will be done</em> ，分开来看</p>
<p>
这种方案只是 <em>Template Method</em> 设计模式的一个例子</p>
</li>
<li>
<p><strong>function pointer data members</strong></p>
<p>
使用函数指针数据成员替代虚函数。在类构造时候，传入函数指针，并用这些函数实现接口功能。缺点在于这些函数只能访问公共接口，而不能直接访问数据成员</p>
</li>
<li>
<p><strong>tr1::function data members</strong></p>
<p>
相对于函数指针，提供更加灵活的动态实现</p>
</li>
<li>
<p><strong>virtual functions in another hierarchy (Strategy Pattern)</strong> </p>
<p>
将两个继承体系进行组合</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-headline-56" class="outline-3">
<h3 id="headline-56">
Item 36: Never redefine an inherited non-virtual function
</h3>
<div id="outline-text-headline-56" class="outline-text-3">
<p>
   如题，违反了公有继承的原则</p>
</div>
</div>
<div id="outline-container-headline-57" class="outline-3">
<h3 id="headline-57">
Item 37: Never redefine a function&#39;s inherited default parameter value
</h3>
<div id="outline-text-headline-57" class="outline-text-3">
<p>
   虚函数是动态绑定，但是默认参数却是静态绑定。在调用虚函数时，会根据当前指针类型决定默认参数。</p>
<p>
   要保证接口的一致性，所有派生类在重定义的时候，需要指定同样的默认参数，但是这样在改的时候很容易改漏掉部分函数。解决办法是使用NVI，用非虚函数实现接口，指定默认参数，然后在虚函数中实现功能，虚函数不设默认参数</p>
</div>
</div>
<div id="outline-container-headline-58" class="outline-3">
<h3 id="headline-58">
Item 38: Model &#34;has-a&#34; or &#34;is-implemented-in-terms-of&#34; through composition
</h3>
<div id="outline-text-headline-58" class="outline-text-3">
<p>复合(composition)是类型之间的一种关系，是一种完全不同于公有继承的建模</p>
<p>
   人、交通工具、视频帧这样的属于应用领域(<em>application domain</em>)，复合意味着&#34;<em><strong>has-a</strong></em>&#34;的关系。</p>
<p>
   缓冲区、互斥锁、搜索树这样的属于软件的实现领域(<em>implementation domain</em>)，符合意味着 <em>is-implemented-in-terms-of</em> 关系</p>
<p>
   例如一个Person类，它包含了名字、地址、电话号码等，这既是 <em>has-a</em> 的关系：</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="p">...</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span> <span class="c1">// composed object
</span><span class="c1"></span>      <span class="n">Address</span> <span class="n">address</span><span class="p">;</span> <span class="c1">// ditto
</span><span class="c1"></span>      <span class="n">PhoneNumber</span> <span class="n">voiceNumber</span><span class="p">;</span> <span class="c1">// ditto
</span><span class="c1"></span>      <span class="n">PhoneNumber</span> <span class="n">faxNumber</span><span class="p">;</span> <span class="c1">// ditto
</span><span class="c1"></span>  <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   又比如用list实现的set模板类，可以说set是根据list实现而出的：</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="c1">// the right way to use list for Set
</span><span class="c1"></span>  <span class="k">class</span> <span class="nc">Set</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="kt">bool</span> <span class="n">member</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
      <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">);</span>
      <span class="kt">void</span> <span class="nf">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">rep</span><span class="p">;</span> <span class="c1">// representation for Set data
</span><span class="c1"></span>  <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-59" class="outline-3">
<h3 id="headline-59">
Item 39: Use private inheritance judiciously
</h3>
<div id="outline-text-headline-59" class="outline-text-3">
<p>
   私有继承意味着 <em>is-implemented-in-terms-of</em> ，只有在软件实现中有意义，而在软件设计中并没有。私有继承往往可以使用 <em>item 38</em> 中的composition来取代：</p>
<ul>
<li>
<p>私有继承允许派生类重写基类的私有函数(即便不能访问)，而composition却是通过私有变量来实现的，派生类无法重载</p>
</li>
<li>
<p>私有继承可能会include必要的实现头文件，会导致增加编译时间，composition却可以只声明，并在实现中使用</p>
</li>
</ul>
<p>私有继承唯一值得使用的情况是，继承一个没有数据成员(包括虚函数)的基类，可以省掉一个最小内存空间，而这是composition做不到的：</p>
<div class="src src-c++">
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">class</span> <span class="nc">Empty</span> <span class="p">{};</span> <span class="c1">// has no data, so objects should
</span><span class="c1"></span>  <span class="c1">// use no memory
</span><span class="c1"></span>  <span class="k">class</span> <span class="nc">HoldsAnInt</span> <span class="p">{</span> <span class="c1">// should need only space for an int
</span><span class="c1"></span>  <span class="k">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
      <span class="n">Empty</span> <span class="n">e</span><span class="p">;</span> <span class="c1">// should require no memory
</span><span class="c1"></span>  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">HoldsAnInt</span><span class="o">:</span> <span class="k">private</span> <span class="n">Empty</span> <span class="p">{</span>
  <span class="k">private</span><span class="o">:</span>
      <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">};</span></code></pre></td></tr></table>
</div>
</div>
</div>
<p>
   第一种方式使用composition，sizeof(HoldsAnInt) &gt; sizeof(int)； 而第二种使用私有继承，借助于 <em>empty base optimization</em> (EBO)优化策略 ，sizeof(HoldsAnInt) = sizeof(int)</p>
</div>
</div>
<div id="outline-container-headline-60" class="outline-3">
<h3 id="headline-60">
Item 40: Use multiple inheritance judiciously   
</h3>
<div id="outline-text-headline-60" class="outline-text-3">
<p>
   多重继承可能存在命名冲突，这时候需要带上对应类型的名字，例如mp.BorrowableItem::checkOut();</p>
<p>
   出现菱形继承的时候，通常使用虚基类来避免基类重复，但是会带来开销，所以尽量不要用虚基类，平常使用非虚继承就好了。如果一定要用到虚基类，尽量避免在其中放入数据，这样就不会遇到初始化、赋值时候诡异的问题了</p>
<p>
   多重继承最常规的用法：公有继承一个接口类的同时，需要私有继承一个类来辅助实现</p>
</div>
</div>
</div>
</div>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">ya0db9</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-02-03
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%8D%87%E7%BA%A7/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">无线网络升级</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/first-hugo-post/">
            <span class="next-text nav-default">Hugo &amp; org mode</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:huyao0302@hotmail.com" class="iconfont icon-email" title="email"></a>
  <a href="https://home.ya0db9.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2018 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>ya0db9</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>








</body>
</html>
